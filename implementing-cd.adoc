= Lab1 - Automating Deployments Using Pipelines
:experimental:

前のシナリオでは、OpenShiftテンプレートを使用して Coolstore monolith を、 *{{USER_ID}}-coolstore-dev* Project にデプロイしました。このテンプレートによって必要なオブジェクト（BuildConfig、DeploymentConfig、ImageStreams、Services、およびRoute）が作成され、開発者としてアプリを実行し、変更を加え、デバッグするための場が提供されました。

このステップでは、別の本番環境を設定し、開発者や DevOps チームが開発者 *(あなたのことです！)* から本番環境にコードを移行する際のベストプラクティスやテクニックを探っていきます。

=== Production vs. Development

既存の *{{USER_ID}}-coolstore-dev* project は、コード変更後のアプリの新バージョンをビルドしてデプロイするための開発環境として利用されています。

OpenShift上の実際のプロジェクトでは、開発環境とテスト環境と本番環境では、通常、異なるOpenShiftプロジェクトを使用し、おそらくは異なるOpenShiftクラスタを使用することになるでしょう。.

このシナリオを簡単にするために、私たちは開発環境と本番環境のみを使用し、テスト/QA環境は使用しません。

==== 1. Create the production environment

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-dev[Topology View^] に戻って、 プロジェクトのドロップダウンをクリックして、 *Create Project* を選択します。

image::create_project.png[create_dialog, 600]

フィールドに必要事項を入力し、 `Create` をクリックします。

* Name: *{{USER_ID}}-coolstore-prod*
* Display Name: *{{USER_ID}} Coolstore Monolith - Production*
* Description: _空欄にする_

[WARNING]
====
プロジェクト名に `{{USER_ID}}-coolstore-prod` を使用しなければなりません。 この名前は後に参照されるため、 `{{USER_ID}}-coolstore-prod` という名前を付けないと失敗することになります。
====

これで *{{USER_ID}}-coolstore-prod* という新しいOpenShiftプロジェクトが作成され、そこから本番アプリケーションが実行されます。

==== 2. Add the production elements

今回は本番用のテンプレートを使ってオブジェクトを作成します。

使用するアプリケーションテンプレートをあらかじめインストールしておきました。 *+Add* をクリックして、 *From Catalog* の項目をクリックします。

image::from_catalog.png[create_new, 700]

検索ボックスに `coolstore` と入力し、 `Coolstore Monolith using pipelines` を選択し、 `Instantiate Template` をクリックします。

image::from_catalog_prod.png[create_new, 700]

以下の項目を記入してください。

* *Namespace*: `{{ USER_ID }}-coolstore-prod` (これは既に選択されているはずです)
* *User ID*: `{{ USER_ID }}`

image::from_catalog_prod_details.png[create_new, 700]

他の値はそのままにして、下にスクロールして *Create* をクリックします。

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に移動して、デプロイされた要素を確認します。

ウェブコンソールの開発者視点の *Topology* view では、プロジェクト内のすべてのアプリケーション、そのビルドステータス、およびそれらに関連するコンポーネントとサービスを視覚的に表示します。

CodeReadyターミナルでこのコマンドを実行することで、コンポーネントに適切なアイコンが表示されるようにラベルを付けます。

[source,sh,role="copypaste"]
----
oc project {{USER_ID}}-coolstore-prod && \
oc label dc/coolstore-prod-postgresql app.openshift.io/runtime=postgresql --overwrite && \
oc label dc/coolstore-prod app.openshift.io/runtime=jboss --overwrite && \
oc label dc/coolstore-prod-postgresql app.kubernetes.io/part-of=coolstore-prod --overwrite && \
oc label dc/coolstore-prod app.kubernetes.io/part-of=coolstore-prod --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/connects-to=coolstore-prod-postgresql --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m2-labs.git --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

image::coolstore_topology.png[create_new, 700]

実行中のpostgresデータベース(紺色の円)と、まだデプロイも起動もされていない coolstore monolith を見ることができます。以前のラボでは、開発者プロジェクトのアプリのバイナリビルドから手動でデプロイしました。このラボでは、CI/CD パイプラインを使用してビルドし、本番環境に自動的にデプロイします。

プロジェクトでは *Jenkins Server* を使用し、Jenkins パイプライン の ビルドストラテジー を使用します。

*Add* をクリックしてから、 *From Catalog* をクリックし、検索ボックスに `jenkins` と入力して、最初の *Jenkins (ephemeral)* アイテムを選択します。

image::from_catalog_jenkins.png[create_new, 700]

*Instantiate Template* をクリックして、以下のフィールドを変更し、他のフィールドはそのままにしておきます。

* *Namespace*: `{{ USER_ID }}-coolstore-prod` (これは既に選択されているはずです)
* *Memory Limit*: `2Gi`
* *Disable memory intensive administrative monitors*: `true`

*Create* をクリックしてください。

新しい Jenkins server にラベルを付けてみましょう。

[source,sh,role="copypaste"]
----
oc label dc/jenkins app.openshift.io/runtime=jenkins --overwrite
----

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に戻ると、本番用のデータベースと、OpenShiftがCI/CDパイプラインの配置を管理するために使用している、Jenkinsと呼ばれるアプリケーションを見ることができます。

image::coolstore_prod_jenkins.png[create_new, 700]

まだ本番環境で動作しているアプリはありません。唯一の稼働中のアプリは、以前バイナリビルドを使ってアプリを稼働させていた開発環境に戻っています。

次のステップでは、OpenShiftのパイプラインビルドを使って、アプリを開発環境から本番環境に昇格させていきます。さっそくやってみましょう。

=== Promoting Apps Across Environments with Pipelines

ここまでは開発環境のOpenShiftに手動でアプリをビルドしてデプロイしてきました。ローカル開発には便利なのですが、テスト環境や本番環境に拡張するとエラーになりやすい配信方法です。

*Continuous Delivery (CD)* とは、デリバリーソフトウェアの様々な側面を自動化することを目的とした一連のプラクティスのことを指します。これらのプラクティスの1つは、デリバリーパイプラインと呼ばれるもので、コードや設定の変更が上位環境に到達し、最終的には本番環境に到達するまでのステップを定義する自動化されたプロセスです。

OpenShiftは人気のある https://jenkins.io/doc/book/pipeline/overview/[Jenkins pipelines^] をプラットフォームに統合することでCI/CD Pipelinesの構築を簡素化し、真に複雑なワークフローをOpenShift内から直接定義できるようにしました。OpenShift 4では、Kubernetes向けのCI/CDの進化形である https://www.openshift.com/learn/topics/pipelines[Tekton Pipelines^] も導入されています。

あらゆるデプロイメントパイプラインの最初のステップは、すべてのコードと設定をソースコードリポジトリに保存することです。今回のワークショップでは、ソースコードと設定を https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m2-labs[GitHub repository^] に保存しています。
を使用しています。

OpenShiftは、開発者がJenkins自動化エンジンで実行するための https://jenkins.io/solutions/pipeline/[Jenkins pipeline^] を定義できるようにすることで、 *Jenkins CI/CD pipelines* をビルトインでサポートしています。

ビルドは、S2Iなどの他のビルドタイプと同じ方法でOpenShiftによって開始、監視、管理されます。パイプラインワークフローは `Jenkinsfile` で定義されており、ビルド設定に直接埋め込まれているか、Git リポジトリで提供され、ビルド設定で参照されます。これらは http://groovy-lang.org/[Groovy scripting language] を使って記述します。

最後のステップで使用した本番環境テンプレートの一部として、Pipeline ビルドオブジェクトが作成されました。通常、パイプラインには、開発環境でプロジェクトをビルドし、結果のイメージをローカルリポジトリに保存し、イメージを実行してそれに対してテストを実行し、結果のイメージをテストや本番環境などの他の環境に転送するために人の承認を待つというステップが含まれています。

==== 3. Inspect the Pipeline Definition

[NOTE]
====
OpenShift Consoleの左メニューにPipelinesというメニュー項目があるのに気づくかもしれません。このメニュー項目はTektonプロジェクトをベースにした新しいパイプライン技術であるTekton Pipelinesを探索するためのものです。このワークショップの一部として、Tektonを探索する他のモジュールもあります。今のところはJenkinsに集中しています。
====

このワークショップの目的のために、パイプラインはやや簡略化されています。パイプラインの内容を確認するには、 {{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs[Build Config page^] に移動して、 `monolith-pipeline` をクリックしてください。

image::prod_bc.png[create_new, 700]

すると、右側にJenkinsfileの詳細が表示されます。

image::coolstore-prod-monolith-bc.png[monolith-pipeline, 700]

また、CodeReady Workspacesのターミナルウィンドウから以下のコマンドで検査することもできます。

[source,sh,role="copypaste"]
----
oc describe bc/monolith-pipeline -n {{USER_ID}}-coolstore-prod
----

パイプライン構文では、複雑なデプロイメントシナリオを作成することができ、 https://jenkins.io/doc/pipeline/steps/[Jenkinsが提供するステップとプラグインの大規模なセット] を使用して手動での相互作用と承認プロセスのチェックポイントを定義することで、チームで使用されるプロセスにパイプラインを適応させることができます。

このワークショップでは、パイプラインを簡単にするために、ビルドとテストをシミュレートして、人間の入力を省略しています。パイプラインが完了すると、 `openshift` オブジェクト内の上記の `tag()` メソッドを使って、開発環境から本番環境にアプリをデプロイします。

==== 4. Promote the dev image to production using the pipeline

ビルドパイプラインを起動してみましょう。

{{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^]　のページで、 *Actions > Start Build* を選択してください。

image::pipe-start.png[Prod, 700]

これでパイプラインが開始されます。パイプラインを開始するのに1～2分かかります! 今後の実行は、Jenkinsのインフラストラクチャがすでにウォームアップされているので、それほど時間はかからないでしょう。パイプラインの進行状況を見ることができます。

image::pipe-prog.png[Prod, 700]

パイプラインが完了したら、 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に戻り、アプリケーションがデプロイされて実行されていることを確認します!

image::pipe-done.png[Prod, 700]

コンテナが完全にデプロイされるまでに時間がかかる場合があります。

*おめでとうございます！* プロジェクトの開発・生産環境のセットアップが完了し、今後のプロジェクトでもこのワークフローを使用することができます。

次のステップでは、パイプラインにヒューマンインタラクション要素を追加して、プロジェクトリーダーであるあなたが変更の承認を担当できるようにします。

==== 5. Adding Pipeline Approval Steps

前のステップでは、OpenShift Pipelineを使用して、開発環境から本番環境への変更のビルドとデプロイのプロセスを自動化しました。このステップでは、パイプラインに最終チェックポイントを追加します。

通常、パイプラインの定義はGitのようなソースコード管理システムにチェックされ、パイプラインを変更するにはソースベースのJenkinsfileを編集します。今回のワークショップでは、直接編集して必要な変更を加えます。 *oc* コマンドでも編集できますが、ここではWebコンソールを使用します。

{{ CONSOLE_URL }}/k8s/ns/{{ USER_ID }}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^] に戻って、 *YAML* タブをクリックします。Deploy to PROD ステージの直前に、パイプラインに新しいステージを追加します。

[NOTE]
====
下の画像のように、以下のコードを *BuildConfig* の適切な場所にコピー＆ペーストする必要があります。
====

[source,groovy, role="copypaste"]
----
            stage ('Approve Go Live') {
              steps {
                timeout(time:30, unit:'MINUTES') {
                  input message:'Go Live in Production (switch to new version)?'
                }
              }
            }
----

最終的なパイプラインは以下のようになります。

image::pipe-edit2.png[Prod, 700]

*Save* をクリックしてください。

==== 6. Make a simple change to the app

承認ステップが整ったので、coolstore のヘッダーの背景色を青に変更したいという、開発者からの変更をシミュレーションしてみましょう。

まず、CodeReadyの `cloud-native-workshop-v2m2-lab` プロジェクトで、CoolStoreアプリのCSSスタイルシートを含む _monolith/src/main/webapp/app/css/coolstore.css_ を開きます。

以下のCSSを追加して、ヘッダーバーの背景をブルーにします（※下の方にコピーして追加します）。

[source,css, role="copypaste"]
----
.navbar-header {
    background: blue
}
----

ここで、monolith アプリケーションのカタログエンドポイントを更新する必要があります。ターミナルで以下のコマンドを実行して、baseUrlをユーザー名で適切な値に更新します。

[source,sh,role="copypaste"]
----
JSPATH="$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith/src/main/webapp/app/services/catalog.js"
CATALOGHOST=$(oc get route -n {{ USER_ID}}-catalog catalog-springboot -o jsonpath={% raw %}"{.spec.host}"{% endraw %})
sed -i 's/REPLACEURL/'$CATALOGHOST'/' "$JSPATH"
----

次に、CodeReady Workspaces Terminalでもう一度アプリを再構築します。

[source,sh,role="copypaste"]
----
mvn clean package -Popenshift -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith
----

そして、CodeReady Workspaces Terminalを介して以前に行ったのと同じように、バイナリビルドを使用して *dev* 環境 に再デプロイします。

[source,sh,role="copypaste"]
----
oc start-build -n {{USER_ID}}-coolstore-dev coolstore --from-file=$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith/deployments/ROOT.war --follow
----
CodeReady Workspaces Terminal経由でデプロイが完了するのを待ちます。

[source,sh,role="copypaste"]
----
oc -n {{USER_ID}}-coolstore-dev rollout status -w dc/coolstore
----

そして、 http://www-{{USER_ID}}-coolstore-dev.{{ ROUTE_SUBDOMAIN }}[Coolstore Dev Web frontend^] に移動して、*dev* アプリケーションで青いヘッダーが表示されていることを確認してください。以下のようになっているはずです。

[WARNING]
====
そうでない場合は、ブラウザの更新を行う必要があるかもしれません。シフトキーを押しながらブラウザの更新ボタンをクリックするか、別の「プライベートブラウザ」セッションを開いてUIにアクセスしてみてください
====

image::nav-blue.png[Dev, 700]

http://www-{{USER_ID}}-coolstore-prod.{{ ROUTE_SUBDOMAIN }}[Coolstore Prod Web frontend^] が元の黒いヘッダーをそのまま使用していることを確認します。

image::pipe-orig.png[Prod, 700]

*dev* での変更は上手くいったので、新しい承認ステップを使って、 *prod* への変更を進めていきましょう。

==== 7. Run the pipeline again

もう一度、 {{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^] に移動して、 *Actions > Start Build* を選択してパイプラインを起動します。

同じパイプラインの進行状況が表示されますが、prodにデプロイする前に、パイプライン内にプロンプトが表示されます。

image::pipe-start2.png[Prod, 700]

*Input Required* のリンクをクリックします。すると新しいタブが開き、Jenkins自体に誘導され、OpenShiftと同じ資格情報でログインできるようになります。

* Username: `{{USER_ID}}`
* Password: `{{OPENSHIFT_USER_PASSWORD}}`

ブラウザ証明書の警告とJenkins/OpenShiftのパーミッションを受け入れると、承認のプロンプトが表示されます。

左メニューの *Console Output* をクリックし、 `Proceed` をクリックする。

image::pipe-jenkins-prompt.png[Prod, 700]

=== 8. Approve the change to go live

*Proceed* をクリックすると、本番環境にプッシュする変更が承認されます。また、変更が不要な場合や承認されていない場合には、パイプラインを直ちに停止する *Abort* をクリックすることもできます。

*Proceed* をクリックすると、Jenkinsからのログファイルが表示され、最終的な進捗状況とデプロイメントが表示されます。

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Production Topology View^] 上で、本番環境のデプロイが完了するのを待ちます(青い丸が全部出てきます！)。

完了したら、 http://www-{{USER_ID}}-coolstore-prod.{{ ROUTE_SUBDOMAIN }}[Coolstore Prod Web frontend^] に新しい変更（青いヘッダー）があることを確認します。

image::nav-blue.png[Prod, 700]

[WARNING]
====
適切なヘルスチェックを設定しておらず、新しいアプリをデプロイする際に Rolling Updates を使用していないため、新しいアプリが利用可能になるまでに数秒かかることがあります。実際の本番環境では、ダウンタイムが発生しないようにするためにこれを使用します。

青いヘッダーが表示されない場合や、 Application Not Available エラーが表示された場合は、しばらく待ってからリロードしてください。それでも黒いヘッダが表示される場合は、シフトキーを押しながらブラウザの更新ボタンをクリックして、強制的に更新してみてください。
====

おめでとうございます。今後の開発者の変更に対して、人間による承認ステップが追加されました。これで、2つのプロジェクトを可視化することができるようになりました。

image::goal.png[Prod, 700]

=== Summary


このラボでは、開発者として OpenShift Container Platform を使用してアプリケーションを構築し、デプロイする方法を学びました。また、OpenShift を使用すると、開発者、アーキテクト、DevOps エンジニアとしての life がいかに楽になるかを学びました。

これらのテクニックを将来のプロジェクトで使用することで、既存のアプリケーションを近代化し、大きなリライトなしで多くの機能を追加することができます。

これまで使用してきたモノリシックアプリケーションは、非常にうまく機能していますが、時代の流れを感じ始めています。アプリのある部分への小さな変更でさえ、本番へのプッシュには多くのチームが関与しなければなりません。
